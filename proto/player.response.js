// @generated by protobuf-ts 2.8.2 with parameter output_javascript
// @generated from protobuf file "player.response.proto" (syntax proto3)
// tslint:disable
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// @generated message type with reflection information, may provide speed optimized methods
class Player$Type extends MessageType {
    constructor() {
        super("Player", [
            { no: 4, name: "streamingData", kind: "message", T: () => Player_StreamingData },
            { no: 10, name: "captions", kind: "message", T: () => Player_Captions }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Player.StreamingData streamingData */ 4:
                    message.streamingData = Player_StreamingData.internalBinaryRead(reader, reader.uint32(), options, message.streamingData);
                    break;
                case /* Player.Captions captions */ 10:
                    message.captions = Player_Captions.internalBinaryRead(reader, reader.uint32(), options, message.captions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* Player.StreamingData streamingData = 4; */
        if (message.streamingData)
            Player_StreamingData.internalBinaryWrite(message.streamingData, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* Player.Captions captions = 10; */
        if (message.captions)
            Player_Captions.internalBinaryWrite(message.captions, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Player
 */
export const Player = new Player$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Player_StreamingData$Type extends MessageType {
    constructor() {
        super("Player.StreamingData", [
            { no: 1, name: "expiresInSeconds", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "adaptiveFormats", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Player_StreamingData_AdaptiveFormats },
            { no: 5, name: "hlsManifestUrl", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { expiresInSeconds: 0, adaptiveFormats: [], hlsManifestUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 expiresInSeconds */ 1:
                    message.expiresInSeconds = reader.int32();
                    break;
                case /* repeated Player.StreamingData.AdaptiveFormats adaptiveFormats */ 3:
                    message.adaptiveFormats.push(Player_StreamingData_AdaptiveFormats.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string hlsManifestUrl */ 5:
                    message.hlsManifestUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 expiresInSeconds = 1; */
        if (message.expiresInSeconds !== 0)
            writer.tag(1, WireType.Varint).int32(message.expiresInSeconds);
        /* repeated Player.StreamingData.AdaptiveFormats adaptiveFormats = 3; */
        for (let i = 0; i < message.adaptiveFormats.length; i++)
            Player_StreamingData_AdaptiveFormats.internalBinaryWrite(message.adaptiveFormats[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string hlsManifestUrl = 5; */
        if (message.hlsManifestUrl !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.hlsManifestUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Player.StreamingData
 */
export const Player_StreamingData = new Player_StreamingData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Player_StreamingData_AdaptiveFormats$Type extends MessageType {
    constructor() {
        super("Player.StreamingData.AdaptiveFormats", [
            { no: 1, name: "itag", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "mimeType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "bitrate", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "width", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "height", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "initRange", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "indexRange", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "lastModified", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 16, name: "quality", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "xtag", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 25, name: "fps", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 26, name: "qualityLabel", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 28, name: "audioTrack", kind: "message", T: () => Player_StreamingData_AdaptiveFormats_AudioTrack },
            { no: 31, name: "averageBitrate", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 42, name: "captionTrack", kind: "message", T: () => Player_StreamingData_AdaptiveFormats_CaptionTrack }
        ]);
    }
    create(value) {
        const message = { itag: 0, url: "", mimeType: "", lastModified: 0, quality: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 itag */ 1:
                    message.itag = reader.int32();
                    break;
                case /* string url */ 2:
                    message.url = reader.string();
                    break;
                case /* string mimeType */ 5:
                    message.mimeType = reader.string();
                    break;
                case /* optional int32 bitrate */ 6:
                    message.bitrate = reader.int32();
                    break;
                case /* optional int32 width */ 7:
                    message.width = reader.int32();
                    break;
                case /* optional int32 height */ 8:
                    message.height = reader.int32();
                    break;
                case /* optional int32 initRange */ 9:
                    message.initRange = reader.int32();
                    break;
                case /* optional int32 indexRange */ 10:
                    message.indexRange = reader.int32();
                    break;
                case /* int64 lastModified = 11 [jstype = JS_NUMBER];*/ 11:
                    message.lastModified = reader.int64().toNumber();
                    break;
                case /* string quality */ 16:
                    message.quality = reader.string();
                    break;
                case /* optional string xtag */ 23:
                    message.xtag = reader.string();
                    break;
                case /* optional int32 fps */ 25:
                    message.fps = reader.int32();
                    break;
                case /* optional string qualityLabel */ 26:
                    message.qualityLabel = reader.string();
                    break;
                case /* optional Player.StreamingData.AdaptiveFormats.AudioTrack audioTrack */ 28:
                    message.audioTrack = Player_StreamingData_AdaptiveFormats_AudioTrack.internalBinaryRead(reader, reader.uint32(), options, message.audioTrack);
                    break;
                case /* optional int32 averageBitrate */ 31:
                    message.averageBitrate = reader.int32();
                    break;
                case /* optional Player.StreamingData.AdaptiveFormats.CaptionTrack captionTrack */ 42:
                    message.captionTrack = Player_StreamingData_AdaptiveFormats_CaptionTrack.internalBinaryRead(reader, reader.uint32(), options, message.captionTrack);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 itag = 1; */
        if (message.itag !== 0)
            writer.tag(1, WireType.Varint).int32(message.itag);
        /* string url = 2; */
        if (message.url !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.url);
        /* string mimeType = 5; */
        if (message.mimeType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.mimeType);
        /* optional int32 bitrate = 6; */
        if (message.bitrate !== undefined)
            writer.tag(6, WireType.Varint).int32(message.bitrate);
        /* optional int32 width = 7; */
        if (message.width !== undefined)
            writer.tag(7, WireType.Varint).int32(message.width);
        /* optional int32 height = 8; */
        if (message.height !== undefined)
            writer.tag(8, WireType.Varint).int32(message.height);
        /* optional int32 initRange = 9; */
        if (message.initRange !== undefined)
            writer.tag(9, WireType.Varint).int32(message.initRange);
        /* optional int32 indexRange = 10; */
        if (message.indexRange !== undefined)
            writer.tag(10, WireType.Varint).int32(message.indexRange);
        /* int64 lastModified = 11 [jstype = JS_NUMBER]; */
        if (message.lastModified !== 0)
            writer.tag(11, WireType.Varint).int64(message.lastModified);
        /* string quality = 16; */
        if (message.quality !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.quality);
        /* optional string xtag = 23; */
        if (message.xtag !== undefined)
            writer.tag(23, WireType.LengthDelimited).string(message.xtag);
        /* optional int32 fps = 25; */
        if (message.fps !== undefined)
            writer.tag(25, WireType.Varint).int32(message.fps);
        /* optional string qualityLabel = 26; */
        if (message.qualityLabel !== undefined)
            writer.tag(26, WireType.LengthDelimited).string(message.qualityLabel);
        /* optional Player.StreamingData.AdaptiveFormats.AudioTrack audioTrack = 28; */
        if (message.audioTrack)
            Player_StreamingData_AdaptiveFormats_AudioTrack.internalBinaryWrite(message.audioTrack, writer.tag(28, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 averageBitrate = 31; */
        if (message.averageBitrate !== undefined)
            writer.tag(31, WireType.Varint).int32(message.averageBitrate);
        /* optional Player.StreamingData.AdaptiveFormats.CaptionTrack captionTrack = 42; */
        if (message.captionTrack)
            Player_StreamingData_AdaptiveFormats_CaptionTrack.internalBinaryWrite(message.captionTrack, writer.tag(42, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Player.StreamingData.AdaptiveFormats
 */
export const Player_StreamingData_AdaptiveFormats = new Player_StreamingData_AdaptiveFormats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Player_StreamingData_AdaptiveFormats_AudioTrack$Type extends MessageType {
    constructor() {
        super("Player.StreamingData.AdaptiveFormats.AudioTrack", [
            { no: 4, name: "displayName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "languageCode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "audioIsDefault", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { displayName: "", languageCode: "", audioIsDefault: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string displayName */ 4:
                    message.displayName = reader.string();
                    break;
                case /* string languageCode */ 5:
                    message.languageCode = reader.string();
                    break;
                case /* bool audioIsDefault */ 6:
                    message.audioIsDefault = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string displayName = 4; */
        if (message.displayName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.displayName);
        /* string languageCode = 5; */
        if (message.languageCode !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.languageCode);
        /* bool audioIsDefault = 6; */
        if (message.audioIsDefault !== false)
            writer.tag(6, WireType.Varint).bool(message.audioIsDefault);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Player.StreamingData.AdaptiveFormats.AudioTrack
 */
export const Player_StreamingData_AdaptiveFormats_AudioTrack = new Player_StreamingData_AdaptiveFormats_AudioTrack$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Player_StreamingData_AdaptiveFormats_CaptionTrack$Type extends MessageType {
    constructor() {
        super("Player.StreamingData.AdaptiveFormats.CaptionTrack", [
            { no: 1, name: "displayName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "vssId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "languageCode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "kind", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { displayName: "", vssId: "", languageCode: "", kind: "", id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string displayName */ 1:
                    message.displayName = reader.string();
                    break;
                case /* string vssId */ 2:
                    message.vssId = reader.string();
                    break;
                case /* string languageCode */ 3:
                    message.languageCode = reader.string();
                    break;
                case /* string kind */ 4:
                    message.kind = reader.string();
                    break;
                case /* string id */ 5:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string displayName = 1; */
        if (message.displayName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.displayName);
        /* string vssId = 2; */
        if (message.vssId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.vssId);
        /* string languageCode = 3; */
        if (message.languageCode !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.languageCode);
        /* string kind = 4; */
        if (message.kind !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.kind);
        /* string id = 5; */
        if (message.id !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Player.StreamingData.AdaptiveFormats.CaptionTrack
 */
export const Player_StreamingData_AdaptiveFormats_CaptionTrack = new Player_StreamingData_AdaptiveFormats_CaptionTrack$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Player_StreamingData_AdaptiveFormats_ColorInfo$Type extends MessageType {
    constructor() {
        super("Player.StreamingData.AdaptiveFormats.ColorInfo", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Player.StreamingData.AdaptiveFormats.ColorInfo
 */
export const Player_StreamingData_AdaptiveFormats_ColorInfo = new Player_StreamingData_AdaptiveFormats_ColorInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Player_Captions$Type extends MessageType {
    constructor() {
        super("Player.Captions", [
            { no: 51621377, name: "playerCaptionsTracklistRenderer", kind: "message", T: () => Player_Captions_PlayerCaptionsTracklistRenderer }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Player.Captions.PlayerCaptionsTracklistRenderer playerCaptionsTracklistRenderer */ 51621377:
                    message.playerCaptionsTracklistRenderer = Player_Captions_PlayerCaptionsTracklistRenderer.internalBinaryRead(reader, reader.uint32(), options, message.playerCaptionsTracklistRenderer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* Player.Captions.PlayerCaptionsTracklistRenderer playerCaptionsTracklistRenderer = 51621377; */
        if (message.playerCaptionsTracklistRenderer)
            Player_Captions_PlayerCaptionsTracklistRenderer.internalBinaryWrite(message.playerCaptionsTracklistRenderer, writer.tag(51621377, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Player.Captions
 */
export const Player_Captions = new Player_Captions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Player_Captions_PlayerCaptionsTracklistRenderer$Type extends MessageType {
    constructor() {
        super("Player.Captions.PlayerCaptionsTracklistRenderer", [
            { no: 1, name: "captionTracks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Player_Captions_PlayerCaptionsTracklistRenderer_CaptionTracks },
            { no: 2, name: "audioTracks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Player_Captions_PlayerCaptionsTracklistRenderer_AudioTracks },
            { no: 3, name: "translationLanguages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Player_Captions_PlayerCaptionsTracklistRenderer_TranslationLanguages },
            { no: 4, name: "defaultAudioTrackIndex", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "defaultCaptionTrackIndex", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { captionTracks: [], audioTracks: [], translationLanguages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Player.Captions.PlayerCaptionsTracklistRenderer.CaptionTracks captionTracks */ 1:
                    message.captionTracks.push(Player_Captions_PlayerCaptionsTracklistRenderer_CaptionTracks.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated Player.Captions.PlayerCaptionsTracklistRenderer.AudioTracks audioTracks */ 2:
                    message.audioTracks.push(Player_Captions_PlayerCaptionsTracklistRenderer_AudioTracks.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated Player.Captions.PlayerCaptionsTracklistRenderer.TranslationLanguages translationLanguages */ 3:
                    message.translationLanguages.push(Player_Captions_PlayerCaptionsTracklistRenderer_TranslationLanguages.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 defaultAudioTrackIndex */ 4:
                    message.defaultAudioTrackIndex = reader.int32();
                    break;
                case /* optional int32 defaultCaptionTrackIndex */ 6:
                    message.defaultCaptionTrackIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated Player.Captions.PlayerCaptionsTracklistRenderer.CaptionTracks captionTracks = 1; */
        for (let i = 0; i < message.captionTracks.length; i++)
            Player_Captions_PlayerCaptionsTracklistRenderer_CaptionTracks.internalBinaryWrite(message.captionTracks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated Player.Captions.PlayerCaptionsTracklistRenderer.AudioTracks audioTracks = 2; */
        for (let i = 0; i < message.audioTracks.length; i++)
            Player_Captions_PlayerCaptionsTracklistRenderer_AudioTracks.internalBinaryWrite(message.audioTracks[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated Player.Captions.PlayerCaptionsTracklistRenderer.TranslationLanguages translationLanguages = 3; */
        for (let i = 0; i < message.translationLanguages.length; i++)
            Player_Captions_PlayerCaptionsTracklistRenderer_TranslationLanguages.internalBinaryWrite(message.translationLanguages[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 defaultAudioTrackIndex = 4; */
        if (message.defaultAudioTrackIndex !== undefined)
            writer.tag(4, WireType.Varint).int32(message.defaultAudioTrackIndex);
        /* optional int32 defaultCaptionTrackIndex = 6; */
        if (message.defaultCaptionTrackIndex !== undefined)
            writer.tag(6, WireType.Varint).int32(message.defaultCaptionTrackIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Player.Captions.PlayerCaptionsTracklistRenderer
 */
export const Player_Captions_PlayerCaptionsTracklistRenderer = new Player_Captions_PlayerCaptionsTracklistRenderer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Player_Captions_PlayerCaptionsTracklistRenderer_CaptionTracks$Type extends MessageType {
    constructor() {
        super("Player.Captions.PlayerCaptionsTracklistRenderer.CaptionTracks", [
            { no: 1, name: "baseUrl", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "message", T: () => Name },
            { no: 3, name: "vssId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "languageCode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "kind", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "rtl", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "isTranslatable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { baseUrl: "", vssId: "", languageCode: "", isTranslatable: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string baseUrl */ 1:
                    message.baseUrl = reader.string();
                    break;
                case /* Name name */ 2:
                    message.name = Name.internalBinaryRead(reader, reader.uint32(), options, message.name);
                    break;
                case /* string vssId */ 3:
                    message.vssId = reader.string();
                    break;
                case /* string languageCode */ 4:
                    message.languageCode = reader.string();
                    break;
                case /* optional string kind */ 5:
                    message.kind = reader.string();
                    break;
                case /* optional bool rtl */ 6:
                    message.rtl = reader.bool();
                    break;
                case /* bool isTranslatable */ 7:
                    message.isTranslatable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string baseUrl = 1; */
        if (message.baseUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.baseUrl);
        /* Name name = 2; */
        if (message.name)
            Name.internalBinaryWrite(message.name, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string vssId = 3; */
        if (message.vssId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.vssId);
        /* string languageCode = 4; */
        if (message.languageCode !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.languageCode);
        /* optional string kind = 5; */
        if (message.kind !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.kind);
        /* optional bool rtl = 6; */
        if (message.rtl !== undefined)
            writer.tag(6, WireType.Varint).bool(message.rtl);
        /* bool isTranslatable = 7; */
        if (message.isTranslatable !== false)
            writer.tag(7, WireType.Varint).bool(message.isTranslatable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Player.Captions.PlayerCaptionsTracklistRenderer.CaptionTracks
 */
export const Player_Captions_PlayerCaptionsTracklistRenderer_CaptionTracks = new Player_Captions_PlayerCaptionsTracklistRenderer_CaptionTracks$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Player_Captions_PlayerCaptionsTracklistRenderer_AudioTracks$Type extends MessageType {
    constructor() {
        super("Player.Captions.PlayerCaptionsTracklistRenderer.AudioTracks", [
            { no: 2, name: "captionTrackIndices", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "defaultCaptionTrackIndex", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "forcedCaptionTrackIndex", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "visibility", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "hasDefaultTrack", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "hasForcedTrack", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "audioTrackId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "captionsInitialState", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { captionTrackIndices: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 captionTrackIndices = 2 [packed = false];*/ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.captionTrackIndices.push(reader.int32());
                    else
                        message.captionTrackIndices.push(reader.int32());
                    break;
                case /* optional int32 defaultCaptionTrackIndex */ 3:
                    message.defaultCaptionTrackIndex = reader.int32();
                    break;
                case /* optional int32 forcedCaptionTrackIndex */ 4:
                    message.forcedCaptionTrackIndex = reader.int32();
                    break;
                case /* optional int32 visibility */ 5:
                    message.visibility = reader.int32();
                    break;
                case /* optional bool hasDefaultTrack */ 6:
                    message.hasDefaultTrack = reader.bool();
                    break;
                case /* optional bool hasForcedTrack */ 7:
                    message.hasForcedTrack = reader.bool();
                    break;
                case /* optional string audioTrackId */ 8:
                    message.audioTrackId = reader.string();
                    break;
                case /* optional int32 captionsInitialState */ 11:
                    message.captionsInitialState = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated int32 captionTrackIndices = 2 [packed = false]; */
        for (let i = 0; i < message.captionTrackIndices.length; i++)
            writer.tag(2, WireType.Varint).int32(message.captionTrackIndices[i]);
        /* optional int32 defaultCaptionTrackIndex = 3; */
        if (message.defaultCaptionTrackIndex !== undefined)
            writer.tag(3, WireType.Varint).int32(message.defaultCaptionTrackIndex);
        /* optional int32 forcedCaptionTrackIndex = 4; */
        if (message.forcedCaptionTrackIndex !== undefined)
            writer.tag(4, WireType.Varint).int32(message.forcedCaptionTrackIndex);
        /* optional int32 visibility = 5; */
        if (message.visibility !== undefined)
            writer.tag(5, WireType.Varint).int32(message.visibility);
        /* optional bool hasDefaultTrack = 6; */
        if (message.hasDefaultTrack !== undefined)
            writer.tag(6, WireType.Varint).bool(message.hasDefaultTrack);
        /* optional bool hasForcedTrack = 7; */
        if (message.hasForcedTrack !== undefined)
            writer.tag(7, WireType.Varint).bool(message.hasForcedTrack);
        /* optional string audioTrackId = 8; */
        if (message.audioTrackId !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.audioTrackId);
        /* optional int32 captionsInitialState = 11; */
        if (message.captionsInitialState !== undefined)
            writer.tag(11, WireType.Varint).int32(message.captionsInitialState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Player.Captions.PlayerCaptionsTracklistRenderer.AudioTracks
 */
export const Player_Captions_PlayerCaptionsTracklistRenderer_AudioTracks = new Player_Captions_PlayerCaptionsTracklistRenderer_AudioTracks$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Player_Captions_PlayerCaptionsTracklistRenderer_TranslationLanguages$Type extends MessageType {
    constructor() {
        super("Player.Captions.PlayerCaptionsTracklistRenderer.TranslationLanguages", [
            { no: 1, name: "languageCode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "languageName", kind: "message", T: () => Name }
        ]);
    }
    create(value) {
        const message = { languageCode: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string languageCode */ 1:
                    message.languageCode = reader.string();
                    break;
                case /* Name languageName */ 2:
                    message.languageName = Name.internalBinaryRead(reader, reader.uint32(), options, message.languageName);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string languageCode = 1; */
        if (message.languageCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.languageCode);
        /* Name languageName = 2; */
        if (message.languageName)
            Name.internalBinaryWrite(message.languageName, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Player.Captions.PlayerCaptionsTracklistRenderer.TranslationLanguages
 */
export const Player_Captions_PlayerCaptionsTracklistRenderer_TranslationLanguages = new Player_Captions_PlayerCaptionsTracklistRenderer_TranslationLanguages$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Name$Type extends MessageType {
    constructor() {
        super("Name", [
            { no: 1, name: "runs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Name_Runs }
        ]);
    }
    create(value) {
        const message = { runs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Name.Runs runs */ 1:
                    message.runs.push(Name_Runs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated Name.Runs runs = 1; */
        for (let i = 0; i < message.runs.length; i++)
            Name_Runs.internalBinaryWrite(message.runs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Name
 */
export const Name = new Name$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Name_Runs$Type extends MessageType {
    constructor() {
        super("Name.Runs", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { text: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Name.Runs
 */
export const Name_Runs = new Name_Runs$Type();
